<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>gym100268k</title>
    <link href="/gym100268k/"/>
    <url>/gym100268k/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/100268">GYM100268k</a></p><p>如你所见，这是一道 Google Code Jam World Finals 2019的压轴（大概是吧）题。</p><span id="more"></span><p><ahref="https://codingcompetitions.withgoogle.com/codejam/round/0000000000432ad5">原题链接</a></p><p>你大概需要一个 Google 账号才能在官方网站上交题。</p><hr /><p>有一天，我的美丽老婆 cftm一直在各种群里喊：“妈的，这傻逼题怎么一直挂啊！”其实我当时还有很多题可以补，但是我觉得这个题非常的有趣，所以就先补了一下这道题。</p><p>给定一个 <span class="math inline">\(n\times m\)</span>的格子，每个格子里要填一个小写字母，已经填好了一部分，要求将剩下的部分填满，并且满足每一个格子的字母的字典序都<strong>不小于</strong>其右边和上面的相邻格子字母的字典序。求有多少种填法，对<span class="math inline">\(10007\)</span> 取模。</p><p><span class="math inline">\(1\le n,m\le 10\)</span>。</p><hr /><p>一开始想了一个看起来很可行的 dp：<spanclass="math inline">\(f(i,l,c)\)</span> 表示填了前 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(l\)</span> 列，右下角为 <spanclass="math inline">\(c\)</span> 的方案数。但显然不能转移（乐）。</p><p>从另一方面去考虑，分 <span class="math inline">\(26\)</span> 次（而非<span class="math inline">\(n\times m\)</span>次）填色，每一次一口气把某一种字母都填完。</p><p>那么被填字母过程大概是这样：</p><p><img src="https://raw.githubusercontent.com/shmilyty/img/main/data/202207272155403.png" style="zoom:150%;" /></p><p>可以发现，当前所有填的字母轮廓线是有一些特点的，具体来说，对于第<span class="math inline">\(i\)</span>行，已填的字母一定是一个前缀，并且前缀长度不长于第 <spanclass="math inline">\(i+1\)</span> 行。</p><p>这样就可以 dp 了，令 <span class="math inline">\(f(i,S)\)</span>表示当前已经填上的字母的位置集合为 <spanclass="math inline">\(S\)</span>，已经枚举过前 <spanclass="math inline">\(i\)</span> 个字母了，有多少种方案。<spanclass="math inline">\(S\)</span> 可以用一个长为 <spanclass="math inline">\(n\)</span> 的 vector 存储，虽然理论上有 <spanclass="math inline">\(m^n\)</span>种，但是由于有不升的限制，因此合法状态并不多。可以用 map存储。在写的时候第一维是可以去掉的。</p><p>写完了之后发现无法通过 <spanclass="math inline">\(n=m=10\)</span>，所有格子都是空 的数据，于是将vector hash 成一个数，便通过了这一题。</p><p>时间复杂度：当 <span class="math inline">\(n=m\)</span> 时，状态数为<span class="math inline">\(26\times \binom{2n} n=\mathcalO(4^nn^{0.5})\)</span>，然而 map 还带了一个 log（悲）。</p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">10007</span>;<br><span class="hljs-type">int</span> n,m,t,p[<span class="hljs-number">11</span>];<br>string s[<span class="hljs-number">10</span>];<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; f;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hsh</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:v)<br>res=res*<span class="hljs-number">11</span>+i+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(k--)<br>x/=<span class="hljs-number">11</span>;<br><span class="hljs-keyword">return</span> x%<span class="hljs-number">11</span><span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br>m=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>cin&gt;&gt;s[i];<br>f[<span class="hljs-built_in">hsh</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">-1</span>))]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i=<span class="hljs-string">&#x27;a&#x27;</span>;i&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> R=<span class="hljs-number">0</span>;R&lt;n;R++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:f)<br>&#123;<br><span class="hljs-type">int</span> val=j.second;<br><span class="hljs-type">int</span> v=j.first;<br><span class="hljs-type">int</span> C=<span class="hljs-built_in">find</span>(v,R);<br><span class="hljs-keyword">if</span>(C+<span class="hljs-number">1</span>&lt;m&amp;&amp;(s[R][C+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>||s[R][C+<span class="hljs-number">1</span>]==i)&amp;&amp;C&lt;(R?<span class="hljs-built_in">find</span>(v,R<span class="hljs-number">-1</span>):m<span class="hljs-number">-1</span>))<br>(f[v+p[R]]+=val)%=mod;<br>&#125;<br>cout&lt;&lt;f[<span class="hljs-built_in">hsh</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,m<span class="hljs-number">-1</span>))]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>p[i]=p[i<span class="hljs-number">-1</span>]*<span class="hljs-number">11</span>;<br>t=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)<br><span class="hljs-built_in">solve</span>(i);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC260Ex Colorfulness</title>
    <link href="/abc260h/"/>
    <url>/abc260h/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://atcoder.jp/contests/abc260/tasks/abc260_h">ABC260H</a></p><span id="more"></span><p>给定 <span class="math inline">\(n\)</span>个小球，每个小球上都有一个数。</p><p>将小球按照任意顺序排列，定义分值为相邻两个小球数不同的对数。</p><p>对于每一个 <spanclass="math inline">\(k\in[1,m]\)</span>，求对于所有排列小球的方案中，分值的<span class="math inline">\(k\)</span> 次方的和，对 <spanclass="math inline">\(998244353\)</span> 取模。</p><p><span class="math inline">\(1\le n,m\le 2.5\times 10^5\)</span></p><hr /><p>第一印象是题面看上去不是很复杂，但是却没有什么可以切入的地方。</p><p>显然无论如何都不可能直接枚举每一种排列方案，因为有 <spanclass="math inline">\(n!\)</span> 种。尝试求贡献，令 <spanclass="math inline">\(A_i\)</span> 表示有多少种（排列）方案分值为 <spanclass="math inline">\(i\)</span>，状态只有 <spanclass="math inline">\(n\)</span> 个。问题就变成了两部分：求 <spanclass="math inline">\(A\)</span>；通过 <spanclass="math inline">\(A\)</span> 快速求出 <spanclass="math inline">\(m\)</span> 个答案。</p><h2 id="容斥原理">容斥原理</h2><p>令 <span class="math inline">\(p_i\)</span> 表示有多少种排列方案有<span class="math inline">\(i\)</span> 对相邻的球上面的数相同，<spanclass="math inline">\(q_i\)</span>表示有多少种排列方案有<strong>至少</strong> <spanclass="math inline">\(i\)</span> 对相邻的球上面的数相同。</p><p>根据定义，可以用 <span class="math inline">\(p\)</span> 表示 <spanclass="math inline">\(q\)</span>： <span class="math display">\[q_i=\sum_{l=i}^{n-1}\binom{l}{i}p_l\]</span> 进行二项式反演可得： <span class="math display">\[\begin{align}p_i&amp;=\sum_{l=i}^{n-1}(-1)^{l-i}\binom{l}{i}q_l\\&amp;={\sum_{l=i}^{n-1}((-1)^{l-i}(l-i)!)(l!q_l)\over i!}\end{align}\]</span></p><p>预处理出 <span class="math inline">\(p_0(i)=(-1)^ii!\)</span> 和<span class="math inline">\(p_1(i)=q_{n-i}(n-i)!\)</span>，那么 <spanclass="math inline">\(p\)</span> 可以看作 <spanclass="math inline">\(p_0\)</span> 和 <spanclass="math inline">\(p_1\)</span> 的卷积，可以在 <spanclass="math inline">\(\Theta(n \log n)\)</span>的时间内算出来，前提是要把 <span class="math inline">\(q\)</span>算出来。</p><p><del>于是便把一个比较难求的问题变成了另一个比较难求的问题</del></p><h2 id="指数生成函数egf">指数生成函数（EGF）</h2><p>先不区分标有相同数的小球（设为 <spanclass="math inline">\(q&#39;\)</span>）。将标有相同的数的小球放到一块去，设标有<span class="math inline">\(c\)</span> 的小球有 <spanclass="math inline">\(m_c\)</span> 个，其中钦定 <spanclass="math inline">\(k_c\)</span> 对相邻，则有 <spanclass="math inline">\(\binom {m_c-1}{k_c}\)</span> 种选法，设为 <spanclass="math inline">\(a_{c,k}\)</span>。确定了相邻的位置，可以将钦定相邻的小球捆绑在一起，即<span class="math inline">\(m_c-k_c\)</span> 个捆绑段，则： <spanclass="math display">\[q’_i=\sum_{k_1,k_2,\dots,k_n,\sum_ck_c=i}\Bigg(\binom{n-i}{m_1-k_1,m_2-k_2,\dots,m_n-k_n}\prod_ca_{c,k}\Bigg)\]</span> 令 <spanclass="math inline">\(r_0=0,r_i=q&#39;_{n-i}(i\ge1)\)</span>，可以将原式化简：<span class="math display">\[r_i=\sum_{k_1,k_2,\dots,k_n,\sum_ck_c=i}\Bigg(\binom i{k_1,k_2,\dots,k_n}\prod_ca_{c,k}\Bigg)\]</span> 这个和 EGF 的乘法形式的系数很像，具体来说，令 <spanclass="math inline">\(g_c(x)=\sum_{k=0}^{m_c}\frac {a_{c,k}}{k!}x^k\)</span>. <span class="math display">\[\prod_cg_c=\sum_{i=0}^{\infty}\Bigg(\sum_{k_1,k_2,\dots,k_n,\sum_ck_c=i}\binomi{k_1,k_2,\dots,k_n}\prod_c a_{c,k}\Bigg){x^i\over i!}\]</span> 可以看出，<spanclass="math inline">\(r_i=i!\times[x^i]\prod_cg_c\)</span>。</p><p><span class="math inline">\(g_c\)</span>的系数很容易求，累乘的过程可以通过归并的方法高效地算出，时间复杂度为<span class="math inline">\(\Theta(n \log^2n)\)</span>。</p><p>由于 <span class="math inline">\(q&#39;\)</span>是不关心标有相同的数的小球的顺序的，因此还要再乘上 <spanclass="math inline">\(\prod_c m_c!\)</span> 才是 <spanclass="math inline">\(q\)</span>。然后能用上面提到的方法算出 <spanclass="math inline">\(p\)</span>，根据定义，<spanclass="math inline">\(A_i=p_{n-i-1}\)</span>，我们终于完成了做法的前半部分。</p><h2 id="普通生成函数ogf">普通生成函数（OGF）</h2><p>我一开始看完求 <span class="math inline">\(A\)</span>的部分后，心想终于结束了，直接 <spanclass="math inline">\(\Theta(n)\)</span> 计算即可，完全没有想起是要求<span class="math inline">\(m\)</span> 个值。显然对于每个 <spanclass="math inline">\(k\in[1,m]\)</span> 来说，答案可以表示为 <spanclass="math inline">\(F(k)=\sum_{i=0}^{n-1} i^kA_i\)</span>，但是不同的<span class="math inline">\(k\)</span>没啥办法直接递推啊。此时便需要考虑再次使用生成函数，将 <spanclass="math inline">\(F(k)\)</span> 转化为某一函数的第 <spanclass="math inline">\(k\)</span> 项系数，如果能求出这个函数，把一次项到<span class="math inline">\(m\)</span> 次项拿出来就可以得到答案。</p><p>令 <span class="math inline">\(f(x)=\sum_{i=0}^\inftyF(i)x^i\)</span>，则 <span class="math display">\[\begin{align}f(x)&amp;=\sum_{i=0}^\infty F(i)x^i\\&amp;=\sum_{i=0}^\infty \bigg(\sum_{k=0}^{n-1}k^iA_k\bigg)x^i\\&amp;=\sum_{k=0}^{n-1}A_k\bigg(\sum_{i=0}^\infty k^ix^i\bigg)\\&amp;=\sum_{k=0}^{n-1}{A_k\over1-kx}\end{align}\]</span> 同样是 <span class="math inline">\(n\)</span>个多项式相加的结果，因此仍然可以用上面所说的归并思路在 <spanclass="math inline">\(\Theta(n\log^2n)\)</span>的运算量内完成，由于是一个分式，所以要用到多项式求逆。</p><p>最后，终于把这道看似很简洁的题目做出来了，时间复杂度为 <spanclass="math inline">\(\Theta(n\log^2n)\)</span>。虽然说目前人均代码量都在4k+，但是大多数地方实现起来都不难，我交了将近10次才通过，原因全部是因为最后多项式求逆这一块的问题，可能是因为以前没有写过，特此记录一下。</p><h2 id="多项式求逆">多项式求逆</h2><p>给定多项式 <span class="math inline">\(f(x)\)</span>，求多项式 <spanclass="math inline">\(f^{-1}(x)\)</span>，使得 <spanclass="math inline">\(f(x)\times f^{-1}(x)\equiv1(\bmodx^k)\)</span>.</p><p>可以肯定的一点是，如同整数在模意义下才存在逆元，多项式求逆也一定是在模<span class="math inline">\(x^k\)</span> 意义下进行的。</p><p>当 <span class="math inline">\(k=1\)</span> 时，<spanclass="math inline">\(f^{-1}(x)\)</span> 就是 <spanclass="math inline">\([x^0]f(x)\)</span> 的逆元。</p><p>假设现在已经求出了模 <span class="math inline">\(x^{\lceil \frac k2\rceil}\)</span> 意义下的逆元 <spanclass="math inline">\(f_0^{-1}(x)\)</span>，如何才能得到 <spanclass="math inline">\(f^{-1}(x)\)</span>？首先有以下等式成立： <spanclass="math display">\[f(x)f_0^{-1}(x)\equiv1(\bmod x^{\lceil \frac k 2\rceil})\\f(x)f^{-1}(x)\equiv1(\bmod x^{\lceil \frac k 2\rceil})\\f_0^{-1}(x)-f^{-1}x\equiv0(\bmod x^{\lceil \frac k 2\rceil})\]</span> 两边平方可得： <span class="math display">\[f_0^{-2}(x)-2f_0^{-1}(x)f^{-1}(x)+f^{-2}(x)\equiv0(\bmod x^k)\]</span> 两边同乘 <span class="math inline">\(f(x)\)</span>并移项可得： <span class="math display">\[f^{-1}(x)=2f_0^{-1}(x)-(f_0^{-1}(x))^2f(x)\]</span>因此每次原问题会被归化成一个完全相同的子问题，数据规模为一半，因此时间复杂度为<span class="math inline">\(\Theta(k\log^2k)\)</span></p><p>看了一下别人的代码，发现可以在最后求 <spanclass="math inline">\(f^{-1}(x)\)</span> 时候将 <spanclass="math inline">\(f_0^{-1}(x),f(x)\)</span>先化为点值形式去做运算，最后再 DFT回来，而不是在每次都做多项式乘法。这样可以减少一半的常数。</p><p>此外我在实现的时候还发现一个问题，初始的多项式 <spanclass="math inline">\(x\)</span> 长度是 <spanclass="math inline">\(O(m)\)</span>的，每次做乘法都会把长度增倍，但是多出来的长度是不会用上的，记录下来反而会造成数组越界，可以在每次做乘法时进行判断，求<span class="math inline">\(f^{-1}(x)\)</span> 时只保留前 <spanclass="math inline">\(k\)</span>项，我一开始没有很好地处理这个问题，导致一直无法通过较大的数据。</p><hr /><p>经过一段时间的学习后发现，如果用迭代的方式代替递归，效率可以得到更进一步的优化！</p><p>放上我最后的实现（洛谷 P4238）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><hr /><p>总结：这一题运用到了很多多项式的知识，比如生成函数，虽然以前学过，但是从来都没有在做题的时候排上用场，通过这一题对推导过程，实现的细节都加深了认识。</p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atcoder</tag>
      
      <tag>maths</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haltoj#226. [220705] Tile</title>
    <link href="/haltoj226/"/>
    <url>/haltoj226/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1d7b2f4ae7653f6dd89facce541b6163d90d677306dd801d0535fa6392eaab0e">ed5dfafb61319e2b01e407a5ad647c67309531e6ef20fc588bddb2833a294809383e28899c700811a7b1b751840c074a190aed30b149126a02bd3be535ee1c80fb65a3c6f45cce89d69fb1e58f0d75f0e8cf8d2eb3a50964faa5e2580fdac4c2c32a50d8d83c231153cbf3ce04ded44ffd96f05c2038cf3fd4898a60da36effadd2fb5dbc9c4264cef085b46eb23f1055092d7bfc9a6452641bc9404bfda0bba8a048e7ab48c20d545b57202f2753b97d2687f46f466955a56c069c64812571ea9cee157db0d2a12741fa49a29c9aa47e5c89ec3f5c87eee588a4b51835e97998ed97b81646afcc6b3d9f3361520b41c96aaf7bbb9a6e4a3ef9db78535b5990c314a0c50bda70fc8f08428cd4dbf2b261102d68e272b8afc9c5fd5695723b807a07ed65d665a8909f2b028dc30e58cce01a1ab69e36017ee0b2831d51a08de5c90802c862f1f2a9bf8694bf0c30a7fdad8789efd97e05175cc8d5438b8685c6f031c391248a4749b0d93e790736035404839a2d0e3ac77d307021c11b24cb6f4985d8aa2623c48ce685c91c52b329d1cabd95c134dfb1d399318de29c896a1ef731b98d8e6ad25239a1c9ceaeff50c6217be006eb9ef036f2f3e3710c54d7810bcd55a7d382898c83bc84a9c2c9960f59f6631aecff03197bf6ce0475b2511fbeb8a203e4c149bb43d6530a430367b1b6b5194d938b57939eafe6d9813d0f705e28633d206c9615d9e47ff1598764b4d119a9ed02e7546ae50a0d6c173b9b86c1c3183c3679421ee073968cbeb937e54a68d288ff3fcc950bead74c2c2c44237b0810f6a4c881a4575460a637dac600c98f2de15e216b0c8763d602641fbdc8cae3d852ebb0dfd6a1fd0838244f68e5cc521a9fc60ed7c41aa9db344c7246227743338b7560e8ef7b133ba2f5378b1571fee1c4795348d5f46f8755aa2c0944916178ee76231a1dca42d4104a07a93ee6520dfaf2ea0dd9da7bddb5ef8dd5f9a64747c0796550421a4ba206b9fe9448dfd1485b3977cf360e3c72c906ba2a9b39880ebea2965fb351a2a221150948874615d89aa4d743d86bf21bfc654801cec2ab2e5d48912e48a1c0ee8e8e490a6891bb1742ffc814df414acd13668ceb235c99d71c67cc92098fc521d35b808b6dfe18441f91935a6a059237e2b2303f70b9b75535d80e6563aba8bf38a544dc50b44303baa0fcc2e0495d7a5e3cad6ff8aee590a5cf2e0da4139a1673df631acf1b044398bf8d94ed5c65b5bd8282e0ef6c6c54f495eca0085c86c17d6a8a87ee03e222f300da2df2b391247c780c500b1e9a1a906bff3c4c87fb6eeb2ec0a3d3f36f6fac38d3c119f28b2c74aa30f7fc2953c481bedd72707bf56e88f0bb0045dd4f85f308fadc0d6f1df5ffe0e3bba317f8b1342fb87b1f02747415782714104019cf2fb90ec10cf47be61d05ea39c9a929a51b162b58d54d1697de681bfc4d8a01a3c7bef8c73d36cb30828daec41eebf675eb0943c22a113afccbc3d401a0fe6c2d4d31be65951b870e4e760c44feb610ae8f8c29aab09a300a792754ade5a8ecf429c067ac7e06ba298cbab01cade8fb58f5aa206f3eafba99c5a178df80d610d326439793c8e5fe3cb96e1eaa4891aec3cb016bc5128527ce11c7ab739cb3ea7041428f02a21ddd6515f6031a74adfe6396190166fc3d7a589ac27ee44091e3edf31fd6fb82448e35a1e0e8d6003a3106c7488438b6acb375f9b5c23e794e258a1f813af0662d4292c3fc99211b4d3c62751b0c52dbcf01d8fcc3169f1d7ffa43ee3783a02c8fe60fa0dce61918002f827e5ee257c350bd2688bb91a1154ebe387d537d827cdcc90de81bc90527d10926bff90e15afef4241fb75c17102fa8739240ed9324e889e1a01e0a7711a3f42f14e5c987d43340599a2b2bfc0222f450a46dff57efbf467d6e10c1e65ef525c857cec1958b2dcec29f107b1a5fa6d3c7873b126ab6e38ce05ec175ce5dcf1d23b218d29f275bf7d12c47106d09d3ff2598caf2875311df76ddd12bee637df49aff789cb99826b3fe78739205a359d8012dcb4de29decfe7fc68d515f25ad88a0e980840cf9baef957b644bac0545c297e9ca94b0247d124c10256514edf99da7afdec0205149264f6fe05dba3aa394835ac4d6780b04dc01c6712567da3cb5bca3c1deea0f8994f815430882a351c603d5e4fc39949c4eb7f8822fdda174ccc263df1260a5fe2b4fd70a887f0a3a179e4a4f67c62b43ef99c01e88643dcc8b6359ccc558ba2a431c8220b87913ea96c6c3e5f67a0e9e44e0eea179a392fc4890a521b9f9302df2926494c31e5bfa9cacd7a3f66edeeeb577043284b7d3a832f035a916f75b7b40560fa2c67e23d1eceb19a8bacce299aee728e8f794d627b1062bfcbb1c146994b34439dcc6d9d907f0c911a05753b1c5e592992dcc890f4e924fea26bbc2371e1530d450d8f4685a7757f6e1a8730d079d6e966a5777ce14ae8fb01b91f1bfc15d5b3fe6cb5e3df5bda6ecd0b0e3302d2e90ec49cb9e5e4523d4417cc44055d8fca5e9b52054e44b9ec150d4eade2a0351776affd8905ba657204117fcafd4f02bc7fbeeea294883ee6b3604f367f52c4982f376c92bb5646228cdae8db02add98462d46a363f483a9a5c2478b34e40bd05a542e109479ab8ffd1baea273b7eb6e58f5300bb638004d91519605e9cf73c0e89e4d0a9385451858dbb20e75d534cf6173feb30c5deaea938cb2b13838af2f9237f2882d7dc9fd5957c25d7b1f0fcf2661e137e09f9dc27c44a7557eca265ff5ce6bd0674ef42a87115007b9238b26dfafba924059d190cb5c0e0220d2833587596a86dd8bb996426ea63726c8d2ea8abf3f5b8511283a3c9dfde9c162cf7eb1ff43910f2294968813e5ffe019986be19d026a637e685f96e961b85ac2e03452b7daeada0c4bf1fc4584aea12b2af58b2232b3355bd461128cd13c968537155abf5079a28d62298cd4016a5fb3796fc62ecc87851015bc92484f265ea0c65c77412b384e0827af01affae759e45380424c6f89e54d0033b76679265cfbaff54bbf21d3be9b682ec2f55a609e78d206d9c7b52dba236a4166322e2b725ea012d2d1f00f7542f1b7f3089960b223e7a7053e456aa26d155742424ec0f361bdb198b7c38163f7f173d086f6b8192d46fb674e143aa9ade29c34b8aa0efec8e353d30551ea802dec80c113a8e9bf71979799c038fbcbd4cb3787d870ba83cde8e1c4cc1e725df0379f4d66a95fb1287eccc0a170f4b763f858f62abca6eff3fd110be27873044caee867d30976d52b2155fe368a722e6c46f9d01dbea6ef4acfeb48059037a5d29e4bd6748a18ff39ec77ea8e24a065dc854f45e0621c0cf3f13379768c2b8f2f90ae3a1a84efe5b228dc903bae2d1c7dbfce55717d6c6381157dbb7333860023d6275b6f6dd4333715d841c0fa7f9cb17d2fd9844690f8df426a20b5f309e6be37cf2653d4e098bba48775a2e448bdf01fb758e394c0ca91606b98ba3ad987d0aa563c5186029489adfac5a1f0db855bf3aa0f15c6ea8907365cfc82460789cb9b7b88aed911b8cc80459f6f66796858879bdfed903bdbd67de06e0bbc9d130f8475e3f60bfd9bd4aefed820367e7c6ea839df7de6f7cb250e23d2200f1088a8cdef6ebd9699996d93f79ddc86428b9228804c6048c4ac275ac27c00d636b88bb9e576eadb5055e36430fbabe027df62a92c47bed231a20ceb0fd2bb87430831859d2917c5c3d965e4a82110228de571d60beebe33485f269740ea09a7e478d5ca43d7aaeccf88114dd642430e7b85a89ee0fa3c67db8b56ac4a2a9aa5b3d2735d2329df6574c2574a02a4abb3a787f407eaa98eba37abbf10fd64c8e9fbf8af2d52a7b1e4d4e422c5d9083cb03a79e78463a124bab622159658a15944e2766c4abc024202778768aa4bb53bec765dc4029a194f9f6a7ce0cdaeec07ef5612f04f427d87cc81f02b26d3ee9fea3055ae65d083ac91a762b25c326c4dc82caea95fc1b72b95fb1f0ba07f8d071e08ca9b80a3a1c991e3475b26534dab4775a64ddc36016fb27dbb7bc193976357c77cfded0298ff8c30011b25f879b27bae8d66c1d4b148989bc35872f351cd279ef143e1b167fa3dad69f1047a8268a6860a303a9b029c3ce12db536b264cea923e0d6c8954f0ac609b67949ddb3ea82f85370875ef8e34bfa1a5c7492a7f1fb8b0309cb2598f1ccd355a8532df12c16ad99c2d2ab9339d65c798824d704894a56e70508aad78a4ecb012f4a3ed489e520f126f806ab6f666b008b14b3bc8b860e82c99c821f67f25fec0e5a44428cb47c86f01c9c040e9db28ebb6e24e8fa4d431a824e1c0eaa5b78712dfdd245e70bf78816ddf65314e2cdd5a4256c9d0607d9ba0b2852b1652fe6438991771b6d39997da8ebf44e7a5ebc11a87eb07205769da73547be9e82cf105f09be684f4667b8e3b24120cf537dbc680a0fed3f5daaefea22d8d384655b88dd4fec9019a4f49a07c56387cc3dc15af6da37476bd4638f26e54cd2bf9146eb7316ad518b8f149324213cca217ecdf9b8c7777fba794d66719b57ebd9d724ac7a52015a8a996c94ad029b6a9d0b5c390b602a83a35bf405c7f623f04fa2af0820dcdb6b7598b765314023e7c13054c408f48179aa9b96c085cc3716619acd016878d4a2464c37474f8703d78482ea9a034a683bae2e451f51f5fc2b9acfc63a5bfad5c4bda2e3a06872e73206d8a6ac66c1272421117ad4fc0b9ddec7986b03f004a5695ea996b354527aff217fbaae0617e47d71080a99705bf9792a6584fd3b50400279067ad8c84fac8e6f13673222f2703aece23b97adc6721bb75100a001f38a7b4dabdef69a81eeec6b74acc14955b3106bde15ac51a1a468d452b779a925356ae823de2dcafb3675fffc958607ca0cc9000eb4d9e3763df9c5bcbc5f34fcb6bbbfdbbbd5ed17396f574e1237b3ed6c664508b27b2f6186890336fcd828703b362d72b28151c37d0102135b321cbefe0d27deb96a40e4ce955694626860175e625687b0ba5344b3c666addfb51d4bcb913b5a2d527bbf4602bbda3f63519ad64583015c8a9add20f47eda6e596b642a79d8853027b919cb97d438533570f521bc1ce20db3f5123e5c8ca76fffcbff87f9b3f694f6878b1265420b6bb9ca928928d884c8b933e2e2cf73d7f105150482d75b2e0175839a510ed8b3953528b08365751b85dc0694b2f61bd75087d943bd296e29e14043a3d2d78539a5f02278170ddc333ebe0e8f149a6e968ed7daf2c0c366a6af274d9307312d8f5e4f8a871103498f3a1d0584f3e41dccb0dda0ce8247f866c6693478da56519fd182d12a054a0cf21c8ab9e95e1338e6d62e599ab6a62b8de216a99f1350025bbba6a64b41c9ed75a88c3903820afce176d5be8c5beb0e76523f87e50429ebdf63b004f97445c0aff41ef7ac399d6c5f8cbd8d7b895e412e51f535765723c9190127cc5ffdc6bc94b82a640b30ad3f01a479b6a3b461662fdfeccb78bce8a6931ae31867734e812ee96ad11a9fdf6361ee8fd88fdc203873126367b63f8353a6957860f9b5bed5744119b00243c79c5b26fe76d4e8fd3832a920e370be9af66f216545199314247a23be3d778df34ebea3386d6e23614a729689a0f9a3815090ef3ccf6f4d60c61af7ec078e27bc485eeb3b12e332e244f19dec3d9518e30419ff61d9925b9a51a8d20c8f349e77d5c7639e18c81f67ac98a67943e0fc7dd20257cb11385c6d9b804318d82047ba53de662713295a6c07e00d77d14805c8e97ce33f6d8f4569023d2eac9078</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">和 wifi 密码对仗（考验各位的对对子能力）</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maths</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ2079 Triangle</title>
    <link href="/poj2079/"/>
    <url>/poj2079/</url>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2079">POJ2079</a></p><span id="more"></span><p>首先，根据海伦公式可以在确定任意三个点的情况下快速计算其面积，其次，这三个点必然在凸包上。</p><p>我一开始认为三角形必然有边在凸包上，因此只需要 <spanclass="math inline">\(\mathcal{O}(n)\)</span>枚举边，再找另外一个点，使得面积最大（将这个点称作枚举的边的匹配点）。这一部分可以用李超线段树维护，时间复杂度可以做到<span class="math inline">\(\mathcal{O}(n\log n)\)</span>。</p><p>但是显然边不一定在凸包上（参考正六边形），是我naïve了。</p><p>但是从李超线段树的角度来说，可以发现一个特点：确定了三角形的一条边，匹配点是唯一（确切来说，是在同一条直线上）的，一定是离这一条边最远的点，如果能把这一条边平移使得和其他点重合，那么另一个点一定是平移距离最远的。</p><p>从另一个角度去分析，这个枚举是具有凸性的，假如确定了一条边，那么可以从这条边相邻的点<span class="math inline">\(p_1\)</span>，次相邻的点 <spanclass="math inline">\(p_2\)</span>，再次相邻的点 <spanclass="math inline">\(p_3\dots\)</span> 依次枚举计算面积，假如有一个点<span class="math inline">\(p_k\)</span>和确定的边所组成的三角形面积小于 <spanclass="math inline">\(p_{k-1}\)</span> 的面积，那么 <spanclass="math inline">\(p_{k-1}\)</span> 一定是“匹配点”。</p><p>如果枚举边就已经 <spanclass="math inline">\(\Theta(n^2)\)</span>了，再用 <spanclass="math inline">\(\log n\)</span>（或 <spanclass="math inline">\(n\)</span>）的运算量确定匹配点很难不TLE，因为每次枚举都要重新确定匹配点，这必然必然会造成信息的的浪费。</p><p>设最后的三个点分别为 <spanclass="math inline">\(p_a,p_b,p_c(a&lt;b&lt;c)\)</span>（按照凸包顺时针进行编号），先枚举<span class="math inline">\(a\)</span>，发现在枚举 <spanclass="math inline">\(b\)</span> 的时候匹配点 <spanclass="math inline">\(c\)</span>一定单调递增，因此可以用双指针直接维护。</p><p>时间复杂度：<span class="math inline">\(\Theta(n^2)\)</span></p><hr /><p>参考代码（吐槽 POJ，2202年了甚至还不支持万能头）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">elif</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALL(x) x.begin(),x.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x&amp;(-x))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">4e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)<br>flag=<span class="hljs-number">0</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> (flag?x:~(x<span class="hljs-number">-1</span>));<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">double</span> x,y;<br>&#125;a[<span class="hljs-number">50001</span>],b[<span class="hljs-number">50001</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> ans;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">d</span><span class="hljs-params">(node x,node y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> p=(<span class="hljs-built_in">d</span>(a[x],a[y])+<span class="hljs-built_in">d</span>(a[y],a[z])+<span class="hljs-built_in">d</span>(a[x],a[z]))/<span class="hljs-number">2.0</span>;<br><span class="hljs-type">double</span> res=<span class="hljs-built_in">sqrt</span>(p*(p-<span class="hljs-built_in">d</span>(a[x],a[y]))*(p-<span class="hljs-built_in">d</span>(a[x],a[z]))*(p-<span class="hljs-built_in">d</span>(a[y],a[z])));<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">check</span><span class="hljs-params">(node a1,node a2,node b1,node b2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> k=<span class="hljs-built_in">check</span>(b[<span class="hljs-number">1</span>],x,b[<span class="hljs-number">1</span>],y);<br><span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">d</span>(b[<span class="hljs-number">0</span>],x)&lt;<span class="hljs-built_in">d</span>(b[<span class="hljs-number">0</span>],y))<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>cin&gt;&gt;b[i].x&gt;&gt;b[i].y;<br><span class="hljs-keyword">if</span>(b[i].y&lt;b[<span class="hljs-number">1</span>].y)<br>&#123;<br><span class="hljs-built_in">swap</span>(b[<span class="hljs-number">1</span>].x,b[i].x);<br><span class="hljs-built_in">swap</span>(b[<span class="hljs-number">1</span>].y,b[i].y);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(b+<span class="hljs-number">2</span>,b+<span class="hljs-number">1</span>+m,cmp);<br>a[<span class="hljs-number">1</span>]=b[<span class="hljs-number">1</span>];<br>n=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">check</span>(a[n<span class="hljs-number">-1</span>],a[n],a[n],b[i])&lt;=<span class="hljs-number">0</span>)<br>n--;<br>a[++n]=b[i];<br>&#125;<br>ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> l=i+<span class="hljs-number">1</span>,j=l+<span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> lst,x;<br><span class="hljs-keyword">for</span>(;j&lt;=n;j++)<br><span class="hljs-keyword">if</span>((x=<span class="hljs-built_in">area</span>(i,l,j))&gt;lst)<br>lst=x;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>j--;<br>ans=<span class="hljs-built_in">max</span>(ans,lst);<br><span class="hljs-keyword">for</span>(l++;l&lt;n;l++)<br>&#123;<br>j=<span class="hljs-built_in">max</span>(j,l+<span class="hljs-number">1</span>);<br>lst=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;j&lt;=n;j++)<br><span class="hljs-keyword">if</span>((x=<span class="hljs-built_in">area</span>(i,l,j))&gt;lst)<br>lst=x;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>j--;<br>ans=<span class="hljs-built_in">max</span>(ans,lst);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>, ans);<br>m=<span class="hljs-built_in">read</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span>(~m)<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>找了一下题解，发现这一题很多人用旋转卡壳做的，实现过程类似，没学过这个算法但还是做出了这个题，感觉很有成就感。</p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maths</tag>
      
      <tag>poj</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AGC031E Snuke the Phantom Thief</title>
    <link href="/agc031e/"/>
    <url>/agc031e/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://atcoder.jp/contests/agc031/tasks/agc031_e">AGC031E</a></p><span id="more"></span><p>瞪了一会，想到大概是一个网络流。</p><p>对于这种整数坐标的常见套路就是将 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>分别放在二分图的两端，中间的每条线代表一颗宝石，一个点可以被多条选出的点包含，最后要最大化选出的边的总权值。由于坐标和宝石的个数都很少，点数边数可以接受。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/shmilyty/img@main/data/1.png" /></p><p>如何将限制建进图里？我一开始把每一个限制转化成二分图里左边（或右边）连续一个区间里所有点被选的总次数不能超过<span class="math inline">\(b\)</span>，但这样有点难办（如果任意两个区间要么没有交集要么嵌套大概是能做的），但是原问题中区间总是一个前缀或一个后缀，因此有可能是有交集但不嵌套。想了半天还是没有解决方案，于是只好爬去看题解。</p><p>还是要利用前缀和后缀这一特殊条件，枚举选出的点数，假设当前选出了<span class="math inline">\(k\)</span> 个点，按照 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 分别从小到大排列，那么 <spanclass="math inline">\(x\le a\)</span> 的点最多有 <spanclass="math inline">\(b\)</span> 个，等价于按照 <spanclass="math inline">\(x\)</span> 从小到大排列，第 <spanclass="math inline">\(b+1\)</span> 个点的 <spanclass="math inline">\(x\)</span> 值大于 <spanclass="math inline">\(a\)</span>；<span class="math inline">\(x\gea&#39;\)</span> 的点最多有 <span class="math inline">\(b&#39;\)</span>个，等价于第 <span class="math inline">\(k-b&#39;\)</span> 个点的 <spanclass="math inline">\(x\)</span> 值小于 <spanclass="math inline">\(a\)</span>，那么就可以将这 <spanclass="math inline">\(k\)</span> 个点每个点的 <spanclass="math inline">\(x\)</span>值的范围求出来，可以利用这个来建图。同样，可以将 <spanclass="math inline">\(k\)</span> 个点按照 <spanclass="math inline">\(y\)</span>值从小到大排列，用相同的做法求出每个点的 <spanclass="math inline">\(y\)</span> 值的范围。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/shmilyty/img@main/data/2.png" /></p><p>具体实现：</p><ul><li>枚举选出的点数 <span class="math inline">\(k\)</span>，将 <spanclass="math inline">\(S\)</span> 向左侧的 <spanclass="math inline">\([1,k]\)</span> 各连一条容量为 <spanclass="math inline">\(1\)</span>，价值为 <spanclass="math inline">\(0\)</span> 的边，将右侧的 <spanclass="math inline">\([1,k]\)</span> 向 <spanclass="math inline">\(T\)</span> 连一条容量为 <spanclass="math inline">\(1\)</span>，价值为 <spanclass="math inline">\(0\)</span> 的边。</li><li>对于左侧 <span class="math inline">\([1,k]\)</span>中每个点，计算出其 <span class="math inline">\(x\)</span>值的取值范围，将这个点向 <span class="math inline">\(x\)</span>的相应范围连一条容量为 <span class="math inline">\(1\)</span>，价值为<span class="math inline">\(0\)</span> 的边。</li><li>对于右侧 <span class="math inline">\([1,k]\)</span>中每个点，计算出其 <span class="math inline">\(y\)</span>值的取值范围，将 <span class="math inline">\(y\)</span>的相应范围向这个点连一条容量为 <spanclass="math inline">\(1\)</span>，价值为 <spanclass="math inline">\(0\)</span> 的边。</li><li>对于每颗宝石，将对应的 <span class="math inline">\(x,y\)</span>连一条容量为 <span class="math inline">\(1\)</span>，价值为 <spanclass="math inline">\(v\)</span> 的边。</li><li>用这个图的<strong>最大费用最大流</strong>更新答案。</li></ul><p>时间复杂度：<spanclass="math inline">\(\mathcal{O}(n^2k^2)\)</span></p><p>咋算？，我母鸡啊。</p><hr /><p>总结：</p><p>一开始之所以考虑将限制转化区间总次数，是因为可以利用容量对一个区间的总次数进行约束，但是这是一个单向的转化，导致无法处理两个区间相交且不嵌套的情况。通过这一题，又掌握了一个网络流的技巧：可以尝试将约束转化为一个范围。</p><p>但这本质上还是限制了区间的总次数，只不过是特殊化了而已：这个总次数固定为<span class="math inline">\(1\)</span>，且区间与区间不会互相影响。</p><hr /><p>bonus：我在前面提出的问题</p><p><imgsrc="https://cdn.jsdelivr.net/gh/shmilyty/img@main/data/3.png" /></p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atcoder</tag>
      
      <tag>flows</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introductions(?)</title>
    <link href="/something/"/>
    <url>/something/</url>
    
    <content type="html"><![CDATA[<p>算是一些阅读须知吧（强烈推荐阅读）。</p><span id="more"></span><p>本博客永久链接：<code>shmilyty.github.io</code>，会自动跳转到当前域名。</p><p>国内同步站：<code>https://shmilyty.gitee.io</code>。</p><p>关于被加密的博文：只能在有证书的网址查看，如果你发现当前网址输入密码（无论正确与否）后没有任何回应，请提醒我更新证书。</p><h1 id="关于题解">关于题解</h1><p>我以前在网上找题解的时候总是特别希望不要光口胡，最好给个代码之类的，一个是学习优秀的实现方法，另一方面有时候讲的实在是令人云里雾里。</p><p>所以我在所有<strong>无法看到别人提交记录</strong>的题里面都会附上我的代码。（但是为了简短会去掉缺省源）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(<span class="hljs-string">&quot;Ofast&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">elif</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALL(x) x.begin(),x.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x&amp;(-x))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fileio</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">freopen</span>((s+<span class="hljs-string">&quot;.in&quot;</span>).<span class="hljs-built_in">c_str</span>(),<span class="hljs-string">&quot;r&quot;</span>,stdin);<br><span class="hljs-built_in">freopen</span>((s+<span class="hljs-string">&quot;.out&quot;</span>).<span class="hljs-built_in">c_str</span>(),<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">4e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)<br>flag=<span class="hljs-number">0</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> (flag?x:~(x<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="关于友链">关于友链</h1><p><del>目前还没有人找我挂友链，因此我暂时不打算开通这一页。</del></p><p>居然有人会找我挂友链，已经开通了。</p><h1 id="关于评论">关于评论</h1><p>众所周知，不需要登录，只需要填一下昵称即可。</p><p>但是多填点不香吗？</p><blockquote><p><del>咕咕咕</del> To be continued.</p></blockquote><p><img src="/img/gugugu.gif" /></p>]]></content>
    
    
    <categories>
      
      <category>introduction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Loj2026 「JLOI / SHOI2016」成绩比较</title>
    <link href="/loj2026/"/>
    <url>/loj2026/</url>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/p/2026">loj2026</a></p><span id="more"></span><hr /><p>计数的要点：不重不漏。这种问题一开始的思路都应该是将所有情况进行“分类”。</p><p>由于具体的成绩（分数）非常大，因此应该从其他数据范围下手，最后再把成绩用组合数之类的东西乘进去。</p><p>只考虑单纯的分值大小关系，可以进行 dp：令 <spanclass="math inline">\(f(i,j)\)</span>​​​ 表示考虑了前 <spanclass="math inline">\(i\)</span>​​​ 个课，目前有 <spanclass="math inline">\(j\)</span>​​​​​ 个人被碾压的方案数，初始状态是 <spanclass="math inline">\(f(0,m-1)=1\)</span>，最后的答案是 <spanclass="math inline">\(f(m,k)\)</span>​​。</p><p>主要难点在于转移，先枚举前 <span class="math inline">\(i-1\)</span>​​个课有 <span class="math inline">\(k(j\le k&lt;n)\)</span>​同学被他碾压，再考虑如何从 <span class="math inline">\(f(i-1,k)\)</span>转移到 <span class="math inline">\(f(i,j)\)</span>。</p><p>对于第 <span class="math inline">\(i\)</span> 个课，可以把这 <spanclass="math inline">\(n-1\)</span>​ 个同学分成三类：</p><ul><li>始终被碾压的 <span class="math inline">\(j\)</span>​个同学，<strong>这一次也被碾压了</strong>。</li><li>前面 <span class="math inline">\(i-1\)</span>​次被碾压，<strong>这一次没有被碾压</strong>的 <spanclass="math inline">\(k-j\)</span>​ 个同学。</li><li>剩下的 <span class="math inline">\(n-k-1\)</span>​​个同学，<strong>这一次的分数无所谓</strong>。</li></ul><p>那么在不考虑如何分配分数的情况下，<spanclass="math inline">\(f(i-1,k)\)</span>​​ 对 <spanclass="math inline">\(f(i,j)\)</span>​​ 的贡献是 <spanclass="math inline">\(f(i-1,k)\times C_k^{k-j}\timesC_{n-k-1}^{r_i-1-(k-j)}\)</span>​​​。其实就是有 <spanclass="math inline">\(r_i-1\)</span>​​个人没有被吊打，其中包含第二类的全部和第三类的部分。 ​</p><p>但是还需要乘以一个系数 <span class="math inline">\(g(i)\)</span>​​，表示有多少种分配分数的方案满足这一次没有被碾压的人数恰好为 <spanclass="math inline">\(r_i-1\)</span>​​个，可以写成一个朴素的求法，即直接枚举 B 神的分数： <spanclass="math display">\[g(i)=\sum_{l=1}^{u_i}l^{n-r_i}(u_i-l-1)^{r_i-1}\]</span> 此时不得不枚举 <spanclass="math inline">\([1,u_i]\)</span>​，一个都不能少。虽然还没有解决<span class="math inline">\(u\)</span>的影响，但是这个式子其实已经非常简洁了，可以先拆一下括号。不需要真的算出结果，但是可以发现<span class="math inline">\(g(i)=\sum_{l=1}^{u_i}F(l)\)</span>，而且<span class="math inline">\(F(i)\)</span> 是一个 <spanclass="math inline">\(n-1\)</span>​​ 次多项式。</p><p>这时候，可以联系 <span class="math inline">\(k\)</span>​次方和得到一个结论：<span class="math inline">\(g(i)\)</span>​是一个未知数为 <span class="math inline">\(u_i\)</span>​ 的 <spanclass="math inline">\(n\)</span>​​ 次多项式，由于 <spanclass="math inline">\(u_i\)</span>​​ 过大，可以直接拉格朗日插值。对于每个<span class="math inline">\(i\)</span>​，记录 <spanclass="math inline">\(g(1),g(2),\dots,g(n+1)\)</span>​，这样可以 <spanclass="math inline">\(O(n)/O(n^2)\)</span>​ 地算出其他任何 <spanclass="math inline">\(g(i)\)</span>​​ 的值。</p><p>时间复杂度：<spanclass="math inline">\(O(nm)\)</span>​，因为对于每个枚举的 <spanclass="math inline">\(i\)</span>​ 的时候只需要进行一次插值。</p><p>我写的做法是 <span class="math inline">\(O(n^2m)\)</span>​​的，因为我懒得写 <span class="math inline">\(O(n)\)</span> 的插值。​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,m,k,u[<span class="hljs-number">101</span>],r[<span class="hljs-number">101</span>],g[<span class="hljs-number">103</span>],C[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>],f[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(y)<br>&#123;<br><span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>)<br>(res*=x)%=mod;<br>(x*=x)%=mod;<br>y&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(g));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=i;l++)<br>(g[i]+=<span class="hljs-built_in">qp</span>(l,n-y)*<span class="hljs-built_in">qp</span>(i-l,y<span class="hljs-number">-1</span>)%mod)%=mod;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> up=<span class="hljs-number">1</span>,down=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=<span class="hljs-number">100</span>;l++)<br><span class="hljs-keyword">if</span>(i!=l)<br>&#123;<br>(up*=(x-l+mod))%=mod;<br>(down*=(i-l+mod))%=mod;<br>&#125;<br>(res+=g[i]*up%mod*<span class="hljs-built_in">qp</span>(down,mod<span class="hljs-number">-2</span>)%mod)%=mod;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br>m=<span class="hljs-built_in">read</span>();<br>k=<span class="hljs-built_in">read</span>();<br>C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<br>&#123;<br>C[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=i;l++)<br>C[i][l]=(C[i<span class="hljs-number">-1</span>][l]+C[i<span class="hljs-number">-1</span>][l<span class="hljs-number">-1</span>])%mod;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>u[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>r[i]=<span class="hljs-built_in">read</span>();<br>f[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-built_in">get</span>(u[i],r[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=k;l&lt;=n;l++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l;j&lt;n;j++)<br><span class="hljs-keyword">if</span>(j-l&lt;=r[i]<span class="hljs-number">-1</span>)<br>(f[i][l]+=f[i<span class="hljs-number">-1</span>][j]*C[j][j-l]%mod*C[n<span class="hljs-number">-1</span>-j][r[i]<span class="hljs-number">-1</span>-(j-l)]%mod)%=mod;<br>(f[i][l]*=t)%=mod;<br>&#125;<br>&#125;<br>cout&lt;&lt;f[m][k]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>总结：我认为这种题最困难的一步是想到可以用拉格朗日插值，有两个线索，第一个是<span class="math inline">\(g(i)\)</span>​ 虽然次数非常奇怪，但是只有<span class="math inline">\(l\)</span>​ 一个底数，另外一个线索是 <spanclass="math inline">\(u\)</span>​ 非常大。</p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maths</tag>
      
      <tag>dp</tag>
      
      <tag>loj</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GYM103069A Namomo Subsequence</title>
    <link href="/gym103069a/"/>
    <url>/gym103069a/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://codeforces.com/gym/103069/problem/A">GYM103069A</a></p><span id="more"></span><hr /><p>求 <span class="math inline">\(S\)</span> 中有多少个长度为 <spanclass="math inline">\(6\)</span>的子序列，第三个和第五个字符相同，第四个和第六个字符相同，其他字符互不相同，即形如<code>ABCDCD</code> 。</p><p><span class="math inline">\(S\le 10^6\)</span> ，字符集 <spanclass="math inline">\(m\)</span> 大小为 <spanclass="math inline">\(62\)</span>。</p><hr /><p>可以想到这种计数题，十有八九需要利用到dp，可以先枚举第三个字符的位置，分别计算前后的个数，显然可以令 <spanclass="math inline">\(f(i,c1,c2)\)</span> 表示长度为 <spanclass="math inline">\(i\)</span> 的前缀中，子序列 <spanclass="math inline">\((c1,c2)\)</span>的个数，后缀同理。但这样的状态数为 <spanclass="math inline">\(O(nm^2)\)</span>，无法通过。</p><p>先去找优化的方向，假如只能提供 <spanclass="math inline">\(O(nm)\)</span>的运算量，必然是枚举第三个字符的位置和 <spanclass="math inline">\(D\)</span> 是什么字符，那么具体的方案就需要 <spanclass="math inline">\(O(nm)\)</span> 预处理，<spanclass="math inline">\(O(1)\)</span> 得到。</p><p>先枚举第三个字符的位置，对于前面 <code>AB</code> 的数量，<spanclass="math inline">\(O(m)\)</span> 统计前面有多少个对 <spanclass="math inline">\((c1,c2)\)</span> 使得不等于第三个字符，这样在枚举<code>D</code> 是什么字符时可以直接 <spanclass="math inline">\(O(1)\)</span> 得到。</p><p>对于后面的部分，需要从后往前进行 dp。</p><ul><li><p>令 <span class="math inline">\(f(i,c1,c2,0)\)</span> 表示从 <spanclass="math inline">\(i\)</span> 开始的后缀中，有多少个 <spanclass="math inline">\((c1,c2)\)</span>。</p></li><li><p>令 <span class="math inline">\(f(i,c1,c2,1)\)</span> 表示从 <spanclass="math inline">\(i\)</span> 开始的后缀中，有多少个 <spanclass="math inline">\((c1,c2,c1)\)</span>。</p></li><li><p>令 <span class="math inline">\(f(i,c1,c2,2)\)</span> 表示从 <spanclass="math inline">\(i\)</span> 开始的后缀中，有多少个 <spanclass="math inline">\((c1,c2,c1,c2)\)</span>。</p></li></ul><p>这三个可以依次递推：<spanclass="math inline">\(f(i,c1,c2,1)\leftarrowf(i-1,c2,c1,0),f(i,c1,c2,2)\leftarrow f(i-1,c2,c1,1)\)</span></p><p>当然，还需要预处理 <spanclass="math inline">\(g(i,c)\)</span>​，表示从 <spanclass="math inline">\(i\)</span>​ 开始的后缀中，有多少个 <spanclass="math inline">\(c\)</span>。</p><p>由于转移 <span class="math inline">\(f(i)\)</span> 只需要 <spanclass="math inline">\(f(i-1)\)</span>的值，所以可以将第一维直接去掉，从后往前 dp，又因为每次在当前后缀前添加一个字符只会更新 <spanclass="math inline">\(O(m)\)</span> 个值，其他值不变，因此也可以在 <spanclass="math inline">\(O(nm)\)</span> 的复杂度内全部预处理出来。</p><p>时间复杂度：<span class="math inline">\(O(nm)\)</span>​</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n,ans,pre[<span class="hljs-number">1000002</span>][<span class="hljs-number">62</span>],f[<span class="hljs-number">62</span>][<span class="hljs-number">62</span>][<span class="hljs-number">2</span>],num[<span class="hljs-number">62</span>];<br><span class="hljs-type">char</span> s[<span class="hljs-number">1000001</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hsh</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br><span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span>(c&lt;<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">36</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<br>n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;<span class="hljs-number">62</span>;l++)<br>pre[i][l]=pre[i<span class="hljs-number">-1</span>][l];<br>pre[i][<span class="hljs-built_in">hsh</span>(s[i])]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;i--)<br>&#123;<br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;<span class="hljs-number">62</span>;l++)<br><span class="hljs-keyword">if</span>(l!=<span class="hljs-built_in">hsh</span>(s[i]))<br>&#123;<br>(tot+=x*pre[i<span class="hljs-number">-1</span>][l]%mod)%=mod;<br>x+=pre[i<span class="hljs-number">-1</span>][l];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;<span class="hljs-number">62</span>;l++)<br><span class="hljs-keyword">if</span>(l!=<span class="hljs-built_in">hsh</span>(s[i]))<br>&#123;<br>(f[<span class="hljs-built_in">hsh</span>(s[i])][l][<span class="hljs-number">1</span>]+=f[l][<span class="hljs-built_in">hsh</span>(s[i])][<span class="hljs-number">0</span>])%=mod;<br>(f[<span class="hljs-built_in">hsh</span>(s[i])][l][<span class="hljs-number">0</span>]+=num[l])%=mod;<br>(ans+=f[l][<span class="hljs-built_in">hsh</span>(s[i])][<span class="hljs-number">1</span>]*(tot-(x-pre[i<span class="hljs-number">-1</span>][l])*pre[i<span class="hljs-number">-1</span>][l]%mod+mod)%mod)%=mod;<br>&#125;<br>num[<span class="hljs-built_in">hsh</span>(s[i])]++;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>总结：这一题给我的启发在于计算 <code>CDCD</code> 的部分时使用的 dp思想，之所以可以用二维表示长度为 <span class="math inline">\(4\)</span>​的字符串是因为有重复，之所以每次转移 <spanclass="math inline">\(O(1)\)</span>，总复杂度 <spanclass="math inline">\(O(nm)\)</span>是因为有很多重复，而且转移的时候每个后缀只有 <spanclass="math inline">\(m\)</span> 个状态是有意义的。</p><p>虽然这一题不是很难，但是这个 dp 的思想适用于很多题目。</p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>dp</tag>
      
      <tag>cf gym</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1634F Fibonacci Additions</title>
    <link href="/cf1634f/"/>
    <url>/cf1634f/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://codeforces.com/contest/1634/problem/F">CF1634F</a></p><span id="more"></span><hr /><p>给定 <span class="math inline">\(n\)</span>​ 个数 <spanclass="math inline">\(a\)</span>，每次可以选择一个区间，将区间对位加上（或减去）Fib 数列。（区间第一个数加（或减） <spanclass="math inline">\(1\)</span>，第二个数加（或减） <spanclass="math inline">\(1\)</span>，第三个数加（或减） <spanclass="math inline">\(2\dots\)</span>​​）</p><p>你要在每次操作后回答询问：所有数是否都是 <spanclass="math inline">\(MOD\)</span> 的倍数。</p><p><span class="math inline">\(n,q\le 3\times 10^5\)</span></p><hr /><p>先从这个题目本身进行考虑，假如区间对位加上的数是毫无规律的，那么就不存在一个低于<span class="math inline">\(O(nq)\)</span>​的做法，由于给定的数据范围无法接受，存在的这个限制（Fib）就尤为重要了。</p><p>我当时场上写了一个线段树，但是由于这个线段树的常数略大，所以 TLE onpretest 9。</p><p>但如果从其他角度更好的利用 Fib 这个限制，可以得到一个线性做法。</p><p>一个区间操作的经典题：当区间加上的数全部相同时，令 <spanclass="math inline">\(f_i=a_i-a_{i-1}\)</span>​，那么当 <spanclass="math inline">\(a_i\)</span>​ 和 <spanclass="math inline">\(a_{i-1}\)</span>​ 同时加上一个相同的数时，<spanclass="math inline">\(f_i\)</span>​​保持不变，换句话说，两个相邻的数同时或同时不在操作区间内时，差分结果是不变的，差分之所以每次修改时只需要修改区间边缘的差分值。<strong>差分算法的核心在于将原数列映射成另一个序列，使得单次修改的复杂度为</strong><span class="math inline">\(O(1)\)</span>​。</p><p>同理，在这个问题中，令 <spanclass="math inline">\(f_i=a_i-a_{i-1}-a_{i-2}\)</span>，那么由于每次操作相邻的三个数的增量<span class="math inline">\(c\)</span> 满足 <spanclass="math inline">\(c_i=c_{i-1}+c_{i-2}\)</span>，三个相邻的数同时或同时不在操作区间内时，对应的<span class="math inline">\(f\)</span> 是不变的。</p><p>由于 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(f\)</span> 存在映射，因此所有 <spanclass="math inline">\(a\)</span> 都是 <spanclass="math inline">\(MOD\)</span>​ 的倍数等价于 <spanclass="math inline">\(f\)</span> 在模意义下全是 <spanclass="math inline">\(0\)</span>，记录 <spanclass="math inline">\(f\)</span> 当前有多少个数非 <spanclass="math inline">\(0\)</span>​ ，每次修改时更新即可。</p><p>时间复杂度： <span class="math inline">\(O(n+q)\)</span></p><p>这一题使我对差分有了一个更深的认识。</p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>ds</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARC112F Die Siedler</title>
    <link href="/arc112f/"/>
    <url>/arc112f/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://atcoder.jp/contests/arc112/tasks/arc112_f">ARC112F</a></p><span id="more"></span><p>首先对于交换操作，可以想到将当前手牌 hash一下，减少交换操作的影响。</p><p>对于一张面值为 <span class="math inline">\(i\)</span>的牌，定义其分值为 <span class="math inline">\(2^{i-1}(i-1)!\)</span>​，定义初始手牌的分值 <span class="math inline">\(A\)</span>为每张手牌的分值和。特判 <span class="math inline">\(A=0\)</span>的情况，那么接下来可以保证手牌一定非空。</p><p>如果将 <span class="math inline">\(2n\)</span> 张面值为 <spanclass="math inline">\(n\)</span> 的牌换成一张面值为 <spanclass="math inline">\(1\)</span> 的牌，总分值会减去 <spanclass="math inline">\(M=(2^{n}n!-1)\)</span>​​，除此之外，交换操作不会改变总分值。因此要尽可能地进行交换操作，直到对于每一个<span class="math inline">\(i(1\le i\le n)\)</span>​，面值为 <spanclass="math inline">\(i\)</span> 的牌的张数小于 <spanclass="math inline">\(2i\)</span>。</p><p>先考虑一个简单情况：假如 <spanclass="math inline">\(m=0\)</span>​​，那么最终的总分值一定是 <spanclass="math inline">\(A \space mod \spaceM\)</span>，又因为最终的手牌一定无法再次进行交换操作，因此相对应的每张牌的个数同样唯一，时间复杂度为<span class="math inline">\(\Theta(n)\)</span>。</p><p>对于一般的情况，用类似的方法求出第 <spanclass="math inline">\(i\)</span> 个牌堆的分值 <spanclass="math inline">\(B_i\)</span>，显然加牌堆的操作等价于分值直接相加。因此可以列出如下等式：<span class="math display">\[A+B_1x_1+B_2x_2+\dots+B_mx_m\equiv v(\mod M)\]</span> 其中，<span class="math inline">\(v\)</span>为最终的总分值，移项后可得： <span class="math display">\[B_1x_1+B_2x_2+\dots+B_mx_m-Mx_{m+1}=v-A\]</span> 这是一个多元一次不定方程，根据裴蜀定理，该方程有整数解当且仅当<span class="math inline">\(v-A\)</span>​​​ 是 <spanclass="math inline">\(g=\gcd(B1,B2,\dots,B_m,M)\)</span>​​​​的倍数。而当原方程有整数解时，必然可以构造出一组非负整数解。这样就去除了牌堆的影响，现在的问题是，对于分值<span class="math inline">\(v\)</span>​​，满足 <spanclass="math inline">\(0\le v&lt;M\)</span>​ 且 <spanclass="math inline">\(v\equiv A(\mod g)\)</span>​时，对应的手牌总数最少是多少。</p><p>其中一种实现方式是暴力枚举 <span class="math inline">\(v\)</span>​​，令<span class="math inline">\(v_0=A\mod\spaceg,v_1=v_0+g,v_2=v_1+g\dots\)</span>​​，对于每一个 <spanclass="math inline">\(v\)</span>​​ ，用 <spanclass="math inline">\(\Theta(n)\)</span>​​ 的时间更新答案。总时间复杂度为<span class="math inline">\(O(\frac {M\times n} g)\)</span>​​，由于 <spanclass="math inline">\(M=2^nn!-1\approx10^{18}\)</span>​​，所以当 <spanclass="math inline">\(g\)</span>​​ 比较小的时候枚举量是无法接受的。</p><p>考虑根号分治，当 <span class="math inline">\(g\ge \sqrt M\)</span>时，直接使用上述做法，复杂度为 <span class="math inline">\(O(\frac{M\times n} g)\)</span>。</p><p>当 <span class="math inline">\(g&lt; \sqrt M\)</span>的时候，根据分治法的思路，应该从<strong>反面</strong>思考这个问题。</p><p>直接 dp，令 <span class="math inline">\(f(i)\)</span> 表示当分值为<span class="math inline">\(i\)</span> 时，最少要多少张牌。</p><p>转移的时候可以枚举加入什么牌，即 <spanclass="math inline">\(f(x)+1\rightarrow f((x+2^{l-1}(l-1)!)\modM)\)</span>​。</p><p>虽然这个状态数是 <span class="math inline">\(O(M)\)</span>的，但是最后的答案可以写成： <span class="math display">\[\min_{v\equiv A(\mod g)} f(v)\]</span> 因此，可以将模 <span class="math inline">\(g\)</span>余数相同的放到同一个状态里，由于更新和求答案都是求最小值，这样并不会影响正确性和转移，同时将状态降为<span class="math inline">\(O(g)\)</span>。</p><p>由于加入一张牌等同于当前分值加上这张牌的分值，因此可以进行转移：<spanclass="math inline">\(f(x)+1 \rightarrow f((x+p) \mod g)\)</span>​ ，其中<span class="math inline">\(p\)</span>是新加入的牌的分值，整个转移过程可以看作求有向图的最短路，可以用 bfs解决，时间复杂度为 <span class="math inline">\(O(n\timesg)\)</span>​。​​</p><p>因此总复杂度看似为 <span class="math inline">\(O(n\sqrtM)\)</span>​​​​​，但由于​ <span class="math inline">\(g\)</span>​​​ 是 <spanclass="math inline">\(M\)</span>​​​ 的约数，而 <spanclass="math inline">\(M=2^nn!-1\)</span>​​​，所以 <spanclass="math inline">\(g\)</span>​​​ 无法非常接近 <spanclass="math inline">\(\sqrtM\)</span>​​​，换句话说，就是无法达到上界，打表发现，运算量最大值是当 <spanclass="math inline">\(n=16,g=1214827\)</span>​​​​ 时，<spanclass="math inline">\(n\timesg=14577924\)</span>​​​​，因此该做法可以通过本题。</p><hr /><p><ahref="https://atcoder.jp/contests/arc112/submissions/20406744">参考代码by august14</a></p><p>这一题其实可以用搜索实现。</p><p>仍然需要用到 <span class="math inline">\(v\equiv A(\mod g)\)</span>的条件，从面值为 <span class="math inline">\(n\)</span>的牌往前依次搜索每张牌用了几张，在搜索的时候需要记录当前面值，当前牌的总数，当前选的所有牌的分值和。</p><p>可以从两个方面进行剪枝：首先可以通过当前牌的总数和最近一次被更新的答案判断是否有必要继续下去，另一方面，可以根据当前选的所有牌的分值和，当前一张牌的分值，还有<span class="math inline">\(v,g\)</span>计算出最后的总分值最大是多少，这样可以进行可行性剪枝。</p><p>这个做法不仅在运行时间上非常快，而且各方面性能都很好，感觉写的非常巧妙。</p><hr /><p>总结：我觉得这一题最精彩的部分就是前面借助 hash进行的一系列推论，用不定方程去表示限制，又由于在原题中不关心每个牌堆具体被取的次数（即方程的解），因此可以通过定理将最后状态的分数用已知量表示出来，从而绕过一个又一个比较麻烦的部分。</p><p>一位伟人说过“如果觉得一个问题无法解决，说明没有抓住其主要矛盾。”这个题目亦是如此，一开始构思的时候只想到可以利用hash 来替代换牌操作，没有大胆地尝试仍用 hash解决，导致绕了一下圈子，这个时候才意识到其实可以考虑“设而不解”，避开牌堆的个数。后来对于<span class="math inline">\(\frac M g\)</span>​比较大的情况再一次陷入僵局，此时应该要想到考虑到问题的关键在于 <spanclass="math inline">\(\frac Mg\)</span>太大，因此枚举的可能分值过多，但是反过来看 <spanclass="math inline">\(g\)</span>比较小。这一点一开始没有想通，看了题解方才恍然大悟。</p>]]></content>
    
    
    <categories>
      
      <category>editorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>atcoder</tag>
      
      <tag>maths</tag>
      
      <tag>sqrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
